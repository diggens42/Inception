before eval starts run:
docker ps -qa | xargs -r docker stop && \
docker ps -qa | xargs -r docker rm && \
docker images -qa | xargs -r docker rmi -f && \
docker volume ls -q | xargs -r docker volume rm && \
docker network ls -q | grep -v '^$' | xargs -r docker network rm


network: host

    The network: host setting in Docker Compose disables Docker’s network isolation and makes the container use the host's network stack directly.
    This means the container shares the same network interfaces as the host machine.
    It is mostly used for performance reasons (e.g., reducing network latency) or for applications that require direct access to the host network (e.g., services that bind to specific ports like DNS servers).

Why is it problematic?

    It bypasses Docker’s network security and can lead to port conflicts.
    Containers lose network isolation, making debugging and management harder.
    Some Docker features (like port mapping with -p) don’t work because the container is already using the host's network.

links:

    The links: directive was used in older versions of Docker Compose to allow containers to communicate with each other.
    It created an implicit network connection between the linked containers and modified the /etc/hosts file inside the containers for name resolution.

Why is it problematic?

    It is deprecated as of Docker Compose v3 and later.
    Instead, Docker recommends using user-defined networks and depends_on for service dependencies.




How Docker and Docker Compose Work (In Simple Terms)

    Docker is like a container ship: it lets you pack and run applications inside containers. A container is like a shipping container that holds everything an app needs (code, libraries, settings) so it runs the same anywhere.
    Docker Compose is like a shipping manager: it helps you define and run multi-container applications using a simple YAML file (docker-compose.yml). Instead of running each container manually, you just use one command (docker-compose up), and it sets up everything (like connecting databases, web servers, etc.).

Difference Between a Docker Image Used With and Without Docker Compose

    Without Docker Compose: You run a single container manually using docker run. You must set up networking, environment variables, and dependencies yourself.
    With Docker Compose: You define everything in docker-compose.yml (multiple services, networks, volumes). Running docker-compose up starts all services together and links them automatically.

Benefits of Docker Compared to Virtual Machines (VMs)

    Lightweight: Docker shares the host OS, while VMs need a full OS for each instance.
    Faster startup: Containers start in seconds, while VMs take minutes.
    Less resource usage: Containers use less RAM & CPU compared to VMs.
    Portability: Docker works the same across different machines, avoiding the “it works on my machine” problem.
    Easy scaling: You can quickly create more containers when needed, unlike VMs that require more setup.


simple explanation of docker-network

    Docker networking allows containers to communicate with each other and with the outside world. It provides different network types depending on the use case:

    Bridge Network (Default) – Containers can talk to each other on the same bridge but are isolated from the host and other networks. Used for standalone container setups.

    Host Network – Removes the network isolation and lets a container share the host machine's network directly. Faster but less isolated.

    Overlay Network – Used in Docker Swarm, allowing containers on different machines to communicate securely.

    Macvlan Network – Assigns a unique MAC address to each container, making it look like a physical device on the network.

    None Network – No network access, useful for security or testing.

    You can create custom networks using docker network create, which allows better control over container communication.







